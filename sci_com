#include <hidef.h> /* for EnableInterrupts macro */
#include "derivative.h" /* include peripheral declarations */

#define emisor PTBD_PTBD0

int delay;
int estado;
char ruido;
char senal;
char valor;

void leds();
void configuracion_init();
void configuracion_ADC();
void configuracion_SCI();
void retardo(int cont);

void main(void) {
	configuracion_init();	
	configuracion_ADC();
	configuracion_SCI();
	
	for(;;){
		if(estado==0){
			emisor = 1;
		}else{
			emisor = 0;
		}
		if(estado == 0){
			senal = ADC1RL;
			retardo(10);
			estado=1;
		}else{
			if(estado == 1){
				ruido = AD1RL;
				retardo(10);
				valor = senal - ruido;
				estado = 0;
			}
		}
			
		SCI2D=valor;
		while(SCI2S1_TC==0){}
		for(delay = 0;delay <=20000;delay++){} // Espera para estabilizar config
	}
}

void configuracion_init(){
	SOPT=0x40;
		estado = 0;
		ruido = 0x00;
		senal = 0x00;
		PTBDD=(PTBDD_PTBDD0_MASK | PTBDD_PTBDD1_MASK  | PTBDD_PTBDD2_MASK  | PTBDD_PTBDD3_MASK);
		PTDDD=(PTDDD_PTDDD0_MASK | PTDDD_PTDDD1_MASK);
		PTCDD=(PTCDD_PTCDD2_MASK);
}

void configuracion_ADC(){
	ADC1SC1_ADCO = 1; // CONTINUA
	//ADC1SC1_AIEN = 0;
	//ADC1SC1_COCO = 0;
	//ADC1SC1_ADCH = 0;
	
/*
	ADC1CFG_MODE = ADC1CFG_MODE_BITNUM; // 8 bits ==0
	ADC1CFG_ADICLK = ADC1CFG_ADICLK_BITNUM; // Reloj de bus=0
*/
	ADC1CFG = 0x00;
	ADC1SC1 = (ADC1SC1_ADCO_MASK| ADC1SC1_ADCH1_MASK | ADC1SC1_ADCH3_MASK); //AD1P10 = PTD2
	retardo(1000); // Espera para estabilizar config
}

void retardo(int cont){
	int n;
	for(n=0; n<cont; cont++);
}

void configuracion_SCI(void){
	////*****************************************
	// comunicacion a 9600 baudios
	// SCI baud rate = BUSCLK/(16xBR)
	// BUSCLK = 4MHz
	// 9600= 4.000.000/(16*26)
	// SBR=0000000011010
	////******************************
	SCI2BDH=0x00;
	SCI2BDL=0b00011010;
	////*****************
	//
	//7 LOOPS =0 RxD and TxD use separate pins.
	//6 SCISWAI =0 SCI clocks continue to run in wait mode so the SCI can be the source of an interrupt that wakes up the CPU
	//5 RSRC =0 This bit has no meaning or effect unless the LOOPS bit is set to 1
	//4 M =0 Bit or 8-Bit Mode Select, Normal â€” start + 8 data bits (LSB First) + stop.
	//3 WAKE =0 Idle-line wakeup
	//2 ILT =0 Idle character bit count starts after start bit.
	//1 PE =0 No hardware parity generation or checking.
	//0 PT =0 Even parity.
	////*****************

	SCI2C1=0x00;

	////*****************
	//
	//7 TIE =0 Transmit Interrupt Enable (for TDRE), Hardware interrupts from TDRE disabled (use polling).
	//6 TCIE =0 Transmission Complete Interrupt Enable (for TC), Hardware interrupts from TC disabled (use polling).
	//5 RIE =0 Receiver Interrupt Enable (for RDRF), Hardware interrupts from RDRF disabled (use polling).
	//4 ILIE =0 Idle Line Interrupt Enable (for IDLE), Hardware interrupts from IDLE disabled (use polling)
	//3 TE =1 Transmitter on.
	//2 RE =1 Receiver on.
	//1 RWU =0 Normal SCI receiver operation.
	//0 SBK =0 Normal transmitter operation.
	////*****************

	SCI2C2=(SCI2C2_RE_MASK|SCI2C2_TE_MASK);

	////*****************
	//
	//7 R8 =0 
	//6 T8 =0 
	//5 TXDIR =0 This bit has no meaning or effect unless the LOOPS bit is set to 1
	//4 TXINV1 =0 Transmit data not inverted
	//3 ORIE =0 Overrun interrupts disabled (use polling).
	//2 NEIE =1 Noise Error, hardware interrupt requested when NF = 1.
	//1 FEIE =0 Framing Error Interrupt disabled (use polling). 
	//0 PEIE =0 Parity error, PF interrupts disabled (use polling).
	////*****************

	SCI2C3=(SCI2C3_NEIE_MASK);
	
}
